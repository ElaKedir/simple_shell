#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdbool.h>

bool handle_exit(char **args);
bool file_exists(char *filename);

void ela_prompt(char **prompt)
{
    if ((write(1, *prompt, strlen(*prompt))) == -1)
    {
        perror("prompt writing error");
        exit(1);
    }
}

int ela_line(char **buffer, size_t *buffsize)
{
    ssize_t rd = 0;
    size_t total = 0;
    char *temp = NULL;
    bool pipe_checker = false;
    *buffer = malloc(*buffsize * sizeof(char));
    if (!*buffer)
    {
        perror("memory allocation error");
        exit(1);
    }
    while (1 && !pipe_checker)
    {
        if (isatty(STDIN_FILENO) == 0)
        {
            pipe_checker = true;
        }
        rd = read(0, *buffer + total, *buffsize - total);
        if (rd == -1)
        {
            perror("line reading error");
            exit(1);
        }
        total += rd;
        if (rd == 0 || (total > 0 && (*buffer)[total - 1] == '\n'))
        {
            break;
        }
        if (total >= *buffsize)
        {
            *buffsize *= 2;
            temp = realloc(*buffer, *buffsize * sizeof(char));
            if (!temp)
            {
                free(*buffer);
                perror("memory allocation error");
                exit(1);
            }
            *buffer = temp;
        }
    }
    (*buffer)[total] = '\0';
    if (rd == 0)
        free(*buffer);
    return 0;
}

void ela_execve(char **args)
{
    pid_t pid = fork();

    if (pid < 0)
    {
        perror("fork failed");
        exit(1);
    }
    else if (pid == 0)
    {
        if (execve(args[0], args, NULL) < 0)
        {
            perror("execution failed");
            exit(1);
        }
    }
    else
    {
        wait(NULL);
    }
}

char *handle_path(char *command)
{
    char *path = NULL;
    char *env_path = strdup(getenv("PATH"));
    if (!env_path)
    {
        perror("memory allocation error");
        exit(1);
    }

    char *token = strtok(env_path, ":");
    while (token)
    {
        char *temp = malloc(strlen(token) + strlen(command) + 2);
        if (!temp)
        {
            perror("memory allocation error");
            exit(1);
        }
        strcpy(temp, token);
        strcat(temp, "/");
        strcat(temp, command);

        if (file_exists(temp))
        {
            path = temp;
            break;
        }
        else
        {
            free(temp);
            token = strtok(NULL, ":");
        }
    }

    free(env_path);
    return path;
}

bool file_exists(char *filename)
{
    if (access(filename, F_OK | R_OK) == 0)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void ela_strtok(char *buffer, char *dlm)
{
        int i = 0;
        char **args = malloc(64 * sizeof(char *));
        char *tkn = strtok(buffer, dlm), *path = NULL, *j = "command not found\n";
        if (handle_exit(args))
        {
                free(path);
                exit(0);
        }
        if (tkn == NULL)
        {
                write(1, j, strlen(j));
                free(args);
                return;
        }
        while (tkn)
        {
                args[i] = tkn;
                i++;
                tkn = strtok(NULL, dlm);
        }
        args[i] = NULL;
        if (args[0][0] != '/')
        {
                path = handle_path(args[0]);
                if (path)
                {
                        args[0] = path;
                }
                else
                {
                        write(1, j, strlen(j));
                        free(args);
                        free(path);
                        return;
                }
        }
        ela_execve(args);
        free(args);
        free(path);
}

void handle_sigint(int sig)
{
    (void)sig;
    write(1, "\nExiting...\n", 12);
    exit(0);
}

bool handle_exit(char **args)
{
        if (strcmp(args[0], "exit") == 0)
        {
                free(args);
                return (true);

                if (args[1] != NULL)
                {
                        write(1, "Warning: arguments after 'exit' ignored.\n", 40);
                }
                free(args);
                exit(0);
        }
        return (false);
}

int main(void)
{
    char *prompt = "#cisfun$ ";
    size_t buffsize = 1024;
    char *buffer = NULL;

    signal(SIGINT, handle_sigint);

    while (1)
    {
        ela_prompt(&prompt);
        int line_status = ela_line(&buffer, &buffsize);
        if (line_status == -1)
        {
            break; // End of input
        }
        if (strlen(buffer) > 0)
        {
            ela_strtok(buffer, " \n\t");
        }
       free(buffer);
        buffer = NULL;
    }

    return 0;
}
